<!DOCTYPE html>
<html lang="en">
<head>
    <title>Knowledge Bits — Common Python Packaging Mistakes</title>
    <meta charset="utf-8"/>
    <meta name="generator" content="Pelican (https://getpelican.com)"/>
    <link rel="stylesheet" href="https://jwodder.github.io/kbits/theme/css/main.css" type="text/css"/>
    <script type="text/javascript" id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    <link href="https://jwodder.github.io/kbits/feeds/posts.atom.xml" type="application/atom+xml" rel="alternate" title="Knowledge Bits Full Atom Feed" />
    <link href="https://jwodder.github.io/kbits/feeds/posts.rss" type="application/rss+xml" rel="alternate" title="Knowledge Bits Full RSS Feed" />
    
        <meta name="description" content="An overview of common mistakes made in creating &amp; building a Python package and how to avoid them"/>
        <meta name="tags" content="Python"/>
        <meta name="tags" content="Python packaging"/>
        <meta name="tags" content="setuptools"/>
        <meta name="tags" content="best practices"/>
        <meta name="tags" content="advice"/>
        <meta name="author" content="John T. Wodder II"/>
        <meta name="keywords" content="Python,Python packaging,setuptools,best practices,advice"/>
</head>

<body>
    <div id="topbar">
        <header>
            <span class="sitename">
                <a href="https://jwodder.github.io/kbits/">Knowledge Bits</a>
            </span>
            <span class="sitesubtitle">References I wish I&#39;d already found</span>
        </header>
    </div>

    <div class="mainrow">
        <div id="navbar">
            <nav>
                <ul>
                    <li><a href="https://jwodder.github.io/kbits/categories/">Categories</a></li>
                    <li><a href="https://jwodder.github.io/kbits/tags/">Tags</a></li>
                    <li><a href="https://github.com/jwodder/kbits">Site Repository</a></li>
                </ul>
            </nav>
                <div class="postfeeds">
                    <img src="https://jwodder.github.io/kbits/theme/images/rss.svg" width="16" height="16"/>
                    <a href="https://jwodder.github.io/kbits/feeds/posts.atom.xml">Atom</a>
                    ·
                    <a href="https://jwodder.github.io/kbits/feeds/posts.rss">RSS</a>
                </div>
        </div>
        <div id="content">
<section>
    <article>
        <header>
            <h1>
                <a href="https://jwodder.github.io/kbits/posts/pypkg-mistakes/" rel="bookmark"
                    title="Permalink to Common Python Packaging Mistakes">Common Python Packaging Mistakes</a>
            </h1>
        </header>
        <footer>
            <table border="1">
                <tr>
                    <th>Posted:</th>
                    <td><time datetime="2020-08-22T00:00:00-04:00" pubdate="1">2020-08-22</time></td>
                </tr>
                <tr>
                    <th>Author:</th>
                    <td>
<span class="fn">John T. Wodder II</span>                    </td>
                </tr>
                <tr>
                    <th>Category:</th>
                    <td><a href="https://jwodder.github.io/kbits/categories/programming/">Programming</a></td>
                </tr>
                <tr>
                    <th>Tags:</th>
                    <td>
<a href="https://jwodder.github.io/kbits/tags/python/">Python</a>, <a href="https://jwodder.github.io/kbits/tags/python-packaging/">Python packaging</a>, <a href="https://jwodder.github.io/kbits/tags/setuptools/">setuptools</a>, <a href="https://jwodder.github.io/kbits/tags/best-practices/">best practices</a>, <a href="https://jwodder.github.io/kbits/tags/advice/">advice</a>                    </td>
                </tr>
                <tr>
                    <th>Page Source:</th>
                    <td><a href="https://github.com/jwodder/kbits/blob/master/src/posts/pypkg-mistakes.rst">[link]</a></td>
                </tr>
            </table>
        </footer>
        <div><p>I think we can all agree that packaging a Python project is harder than it
should be.  With numerous guides &amp; tutorials out there, people still make
mistakes.  Some of these mistakes break a project, some just make it less
attractive, and some even cause a project to step on the toes of other
projects.</p>
<p>As the admin of the wheel-analysis and -browsing site <a class="reference external" href="https://www.wheelodex.org">Wheelodex</a>, I see a
number of poorly-built wheels each morning as I peruse the day’s new entries.
This eventually motivated me to create <a class="reference external" href="https://github.com/jwodder/check-wheel-contents">check-wheel-contents</a> — a program for
scanning a wheel for many of the below problems plus several others — in an
attempt to get people to clean up their wheels, yet still the poorly-packaged
projects persist.</p>
<p>In yet another attempt to get people to fix their broken packages, here now are
some of the more frequent types of mistakes I see — along with advice on how to
avoid &amp; correct them — in no particular order.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Unless otherwise specified, references to packaging configurations assume
that the project is using setuptools and that configuration is being placed
in <tt class="docutils literal">setup.py</tt> instead of <tt class="docutils literal">setup.cfg</tt>.  Consult the appropriate
documentation if your project is structured differently.</p>
</div>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#avoiding-general-mistakes" id="id13">Avoiding General Mistakes</a><ul>
<li><a class="reference internal" href="#look-at-your-built-distributions" id="id14">Look at Your Built Distributions</a></li>
<li><a class="reference internal" href="#installations-are-not-namespaced" id="id15">Installations are Not Namespaced</a></li>
</ul>
</li>
<li><a class="reference internal" href="#top-level-tests-directory-in-wheel" id="id16">Top-Level <tt class="docutils literal">tests/</tt> Directory in Wheel</a></li>
<li><a class="reference internal" href="#top-level-readme-or-license-file-in-wheel" id="id17">Top-Level <tt class="docutils literal">README</tt> or <tt class="docutils literal">LICENSE</tt> File in Wheel</a></li>
<li><a class="reference internal" href="#project-description-doesn-t-render" id="id18">Project Description Doesn’t Render</a></li>
<li><a class="reference internal" href="#project-description-not-included" id="id19">Project Description Not Included</a></li>
<li><a class="reference internal" href="#python-package-not-included-in-wheel" id="id20">Python Package Not Included in Wheel</a></li>
<li><a class="reference internal" href="#subpackages-not-included-in-wheel" id="id21">Subpackages Not Included in Wheel</a></li>
<li><a class="reference internal" href="#package-data-not-included-in-wheel" id="id22">Package Data Not Included in Wheel</a></li>
<li><a class="reference internal" href="#pyc-files-included-in-wheel" id="id23"><tt class="docutils literal">*.pyc</tt> Files Included in Wheel</a></li>
<li><a class="reference internal" href="#rebuilding-wheels-without-deleting-build" id="id24">Rebuilding Wheels without Deleting <tt class="docutils literal">build/</tt></a></li>
<li><a class="reference internal" href="#pinning-project-requirements-to-exact-versions" id="id25">Pinning Project Requirements to Exact Versions</a></li>
<li><a class="reference internal" href="#conclusion" id="id26">Conclusion</a></li>
<li><a class="reference internal" href="#footnotes" id="id27">Footnotes</a></li>
</ul>
</div>
<div class="section" id="avoiding-general-mistakes">
<h2><a class="toc-backref" href="#contents">Avoiding General Mistakes</a></h2>
<p>First, some general advice that will help you avoid (or at least detect) the
vast majority of packaging errors.</p>
<div class="section" id="look-at-your-built-distributions">
<h3><a class="toc-backref" href="#contents">Look at Your Built Distributions</a></h3>
<p>Before you upload your sdist and wheel (especially if it’s your first release
for the project in question), actually take a look at what files are inside and
make sure that everything you want to include is in there.  An sdist is either
a tarball (<tt class="docutils literal">*.tar.gz</tt>) or a zipfile (<tt class="docutils literal">*.zip</tt>), so its contents can be
listed with one of these two commands:</p>
<pre class="code shell literal-block">
<span class="c1"># Tarball
</span>$ tar ztf projectname-version.tar.gz

<span class="c1"># Zipfile
</span>$ zipinfo projectname-version.zip
</pre>
<p>At time of writing, the exact layout of an sdist has yet to be standardized,
but if you’re building with a recent version of setuptools, the contents are
structured as follows:</p>
<ul class="simple">
<li>Everything in the sdist is inside a top-level directory named
<tt class="docutils literal"><span class="pre">{projectname}-{version}/</span></tt>.  This directory contains a copy of your package
code, the project’s <tt class="docutils literal">setup.py</tt>/<tt class="docutils literal">pyproject.toml</tt> file, and various other
files from your project directory; see <a class="reference external" href="https://packaging.python.org/guides/using-manifest-in/">here</a> for more
information on what gets included by default.</li>
<li>There exists a <tt class="docutils literal"><span class="pre">PKG-INFO</span></tt> file containing the project metadata.  For
historical reasons, this does not include project dependencies.</li>
<li>Next to your Python package, there is a <tt class="docutils literal"><span class="pre">{projectname}.egg-info/</span></tt> directory
containing more metadata, including a copy of <tt class="docutils literal"><span class="pre">PKG-INFO</span></tt>, a <tt class="docutils literal">SOURCES.txt</tt>
file listing the files in the sdist, and a <tt class="docutils literal">requires.txt</tt> file listing your
project’s dependencies.  Other files may be present depending on what
features your project uses.</li>
</ul>
<p>If your sdist is missing some files from your project directory or contains
some files that you don’t want in there, then (assuming you’re building your
project with setuptools), you can adjust what gets included via <a class="reference external" href="https://packaging.python.org/guides/using-manifest-in/">a <tt class="docutils literal">MANIFEST.in</tt> file</a> and rebuild.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Exactly what files should and should not be included in an sdist is, for
the most part, largely a matter of opinion, but your sdist needs to include
your Python code and anything from your project directory that’s needed to
built a complete wheel.  The files that setuptools includes by default
should generally be left in there, and most people will recommend also
including tests and documentation.  Things that should generally be left
out include <tt class="docutils literal">*.pyc</tt> files, repository metadata like <tt class="docutils literal">.gitignore</tt> and
<tt class="docutils literal">.hgtags</tt>, and (except in special circumstances) anything that you
wouldn’t commit to version control.</p>
</div>
<p>Wheels (<tt class="docutils literal">*.whl</tt>), meanwhile, are just zipfiles with a funny extension, so you
can list their contents with <tt class="docutils literal">zipinfo</tt>.  The basic layout of a wheel is as
follows:</p>
<ul class="simple">
<li>Your Python package is located at the root of the wheel, rather than inside
a directory.</li>
<li>There exists a <tt class="docutils literal"><span class="pre">{projectname}-{version}.dist-info/</span></tt> directory containing
metadata: a <tt class="docutils literal">METADATA</tt> file describing the project (similar to an sdist’s
<tt class="docutils literal"><span class="pre">PKG-INFO</span></tt>, but including dependencies), a <tt class="docutils literal">WHEEL</tt> file describing the
wheel version and tags, and a <tt class="docutils literal">RECORD</tt> file listing the files in the wheel
and their hashes.  Licenses included in the wheel with the <tt class="docutils literal">license_files</tt>
setting also end up in this directory.  Other files may also be present
depending on what features your project uses and the versions of setuptools
and wheel used to build the wheel.</li>
<li>If your project includes any files that are installed outside of
<tt class="docutils literal"><span class="pre">site-packages</span></tt> — headers, scripts, data files (not to be confused with
package data), etc. — they are stored in a <tt class="docutils literal"><span class="pre">{projectname}-{version}.data/</span></tt>
directory.  Files in this directory are organized into subdirectories named
after the the distutils scheme keys (<tt class="docutils literal">purelib</tt>, <tt class="docutils literal">platlib</tt>, <tt class="docutils literal">headers</tt>,
<tt class="docutils literal">scripts</tt>, or <tt class="docutils literal">data</tt>) that map to the files’ install locations.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Aside from the <tt class="docutils literal"><span class="pre">*.dist-info/</span></tt> and <tt class="docutils literal">*.data/</tt> directories, a wheel should
only contain Python packages &amp; modules, consisting of code and data files.
Files like your project’s <tt class="docutils literal">setup.py</tt>, <tt class="docutils literal">pyproject.toml</tt>, <tt class="docutils literal">setup.cfg</tt>,
etc. do not belong in a wheel.</p>
</div>
<p>Controlling what gets included in a wheel is more involved than for an sdist
(when using setuptools, at least); consult documentation elsewhere on how to do
this.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Do NOT try to fix your sdists or wheels by manually adding, removing, or
editing the files inside, as this is likely to make the sdist/wheel
invalid.  Instead, change your project configuration and create new built
distributions until you get what you want — <a class="reference internal" href="#rebuild-noclean">and be sure to delete the <tt class="docutils literal">build/</tt> directory in
between builds!</a></p>
</div>
</div>
<div class="section" id="installations-are-not-namespaced">
<h3><a class="toc-backref" href="#contents">Installations are Not Namespaced</a></h3>
<p>A key thing to understand about how Python packages are installed is that
(almost) all of the files in a wheel are simply placed directly in
<tt class="docutils literal"><span class="pre">site-packages/</span></tt>; the only subdirectories present will be the directories
that are already in the wheel.  This means that, if your wheel has a <tt class="docutils literal">foo/</tt>
directory at the top level containing <tt class="docutils literal">bar.py</tt>, then <tt class="docutils literal">bar.py</tt> will be
installed to <tt class="docutils literal"><span class="pre">site-packages/foo/bar.py</span></tt>; nothing is added to the path to
separate it from other packages’ <tt class="docutils literal">foo/bar.py</tt> files.  Properly namespacing
your files must be done by putting everything under a directory (normally your
top-level Python package) with a name the same as or similar to the name of
your project — which is the standard practice anyway.  Where problems arise is
when a top-level file or directory in a wheel has a name that other projects
are also likely to use, in which case files end up overwritten with the wrong
content and bugs result.</p>
<p>See <a class="reference external" href="https://github.com/pypa/pip/issues/4625">pip issue #4625</a> for pip’s
attempts at handling file collisions whenever they arise.</p>
</div>
</div>
<div class="section" id="top-level-tests-directory-in-wheel">
<h2><a class="toc-backref" href="#contents">Top-Level <tt class="docutils literal">tests/</tt> Directory in Wheel</a></h2>
<p>The first (and probably most common) Python packaging mistake occurs when you
put your tests in a <tt class="docutils literal">tests/</tt> directory at the root of your project (outside
of your Python package) and then include this directory in your project’s
wheels.  The <tt class="docutils literal">tests/</tt> directory then ends up placed at the top-level of your
wheel’s filesystem, and, <a class="reference internal" href="#installations-are-not-namespaced">as stated above</a>, this means that it will be installed at
<tt class="docutils literal"><span class="pre">site-packages/tests/</span></tt>.  The problem comes from the fact that “<tt class="docutils literal">tests/</tt>” is
a name that <em>everybody</em> uses for their tests and too many other projects also
include a top-level <tt class="docutils literal">tests/</tt> directory in their wheels.  As a result,
<tt class="docutils literal"><span class="pre">site-packages/tests/</span></tt> becomes a mish-mash of code from different packages,
some files even overwriting each other, and if someone tries to run those
tests, chaos will ensue.  (And if you don’t expect people to be running your
tests from your installed project, why are you including tests in the wheel in
the first place?)</p>
<p>The most common reason why <tt class="docutils literal">tests/</tt> ends up included in wheels is because the
project’s author used <tt class="docutils literal">find_packages()</tt> in their <tt class="docutils literal">setup.py</tt> but didn’t use
the function’s <tt class="docutils literal">exclude</tt> argument.  <tt class="docutils literal">find_packages()</tt> works by searching
for directories in the project root (or in the directory passed as the
<tt class="docutils literal">where</tt> argument) that contain an <tt class="docutils literal">__init__.py</tt> file, and then it searches
those directories for any subdirectories that also contain an <tt class="docutils literal">__init__.py</tt>
file, and so on until it runs out of directories with <tt class="docutils literal">__init__.py</tt> files.
Sometimes, people put an <tt class="docutils literal">__init__.py</tt> file in <tt class="docutils literal">tests/</tt> (Whether this is
necessary depends on the test framework being used), and so <tt class="docutils literal">find_packages()</tt>
with the default arguments picks it up and adds it to the project’s list of
packages, resulting in it being included in the wheel.</p>
<p>To avoid this, you have five options:</p>
<ol class="arabic">
<li><p class="first">Remove the <tt class="docutils literal">__init__.py</tt> files from your <tt class="docutils literal">tests/</tt> directory and its
subdirectories.  Whether this is doable depends on your test framework.</p>
</li>
<li><p class="first">Use <tt class="docutils literal">find_packages()</tt>’s <tt class="docutils literal">exclude</tt> argument to exclude <tt class="docutils literal">tests/</tt> and its
subdirectories like so:</p>
<pre class="code python literal-block">
<span class="n">packages</span><span class="o">=</span><span class="n">find_packages</span><span class="p">(</span><span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;tests&quot;</span><span class="p">,</span> <span class="s2">&quot;tests.*&quot;</span><span class="p">])</span>
</pre>
<p>Note that we list both <code class="py python"><span class="s2">&quot;tests&quot;</span></code> and <code class="py python"><span class="s2">&quot;tests.*&quot;</span></code>.  Listing just
<code class="py python"><span class="s2">&quot;tests&quot;</span></code> would exclude <tt class="docutils literal">tests/</tt> but not its subdirectories, so we
need to also list <code class="py python"><span class="s2">&quot;tests.*&quot;</span></code> in order to exclude everything.</p>
</li>
<li><p class="first">Use <tt class="docutils literal">find_packages()</tt>’s <tt class="docutils literal">include</tt> argument to include only your Python
package and its subpackages like so:</p>
<pre class="code python literal-block">
<span class="n">packages</span><span class="o">=</span><span class="n">find_packages</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;packagename&quot;</span><span class="p">,</span> <span class="s2">&quot;packagename.*&quot;</span><span class="p">])</span>
</pre>
<p>As with <tt class="docutils literal">exclude</tt>, we list both the package name and the package name
followed by “<tt class="docutils literal">.*</tt>” so that all subpackages of the package will be matched
&amp; included.</p>
</li>
<li><p class="first">Move your <tt class="docutils literal">tests/</tt> directory inside your Python package directory so it’s
no longer at the top level.</p>
</li>
<li id="src"><p class="first">Switch your project to a <tt class="docutils literal">src/</tt> layout, where your Python package
directory is located inside a directory named <tt class="docutils literal">src/</tt> and everything else —
including <tt class="docutils literal">tests/</tt> — is outside of <tt class="docutils literal">src/</tt>.  With this layout, simply
write your <tt class="docutils literal">packages</tt> line as <code class="py python"><span class="n">packages</span><span class="o">=</span><span class="n">find_packages</span><span class="p">(</span><span class="s2">&quot;src&quot;</span><span class="p">)</span></code>, and
<tt class="docutils literal">find_packages()</tt> will only look at what’s in <tt class="docutils literal">src/</tt>.</p>
<p>Note that you will also need to add <code class="py python"><span class="n">package_dir</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;&quot;</span><span class="p">:</span> <span class="s2">&quot;src&quot;</span><span class="p">}</span></code> to your
<tt class="docutils literal">setup()</tt> arguments in order for setuptools to grok your layout.  More
information about the <tt class="docutils literal">src/</tt> layout can be found <a class="reference external" href="https://blog.ionelmc.ro/2014/05/25/python-packaging/#the-structure">here</a> and <a class="reference external" href="https://hynek.me/articles/testing-packaging/">here</a>.</p>
</li>
</ol>
<p>The second most common reason why <tt class="docutils literal">tests/</tt> ends up in wheels is that the
project author used the <tt class="docutils literal">exclude</tt> argument to <tt class="docutils literal">find_packages()</tt> but listed
only <code class="py python"><span class="s2">&quot;tests&quot;</span></code> and not <code class="py python"><span class="s2">&quot;tests.*&quot;</span></code>, and so the subdirectories of
<tt class="docutils literal">tests/</tt> (inside an otherwise-empty <tt class="docutils literal">tests/</tt> directory) ended up in the
wheel.  Both <code class="py python"><span class="s2">&quot;tests&quot;</span></code> and <code class="py python"><span class="s2">&quot;tests.*&quot;</span></code> need to be included in the
<tt class="docutils literal">exclude</tt> list in order to exclude the entire <tt class="docutils literal">tests/</tt> hierarchy.</p>
<p>Besides <tt class="docutils literal">tests/</tt>, it is also a problem to include a top-level directory named
<tt class="docutils literal">test/</tt> (singular), <tt class="docutils literal">docs/</tt>, <tt class="docutils literal">examples/</tt>, <tt class="docutils literal">data/</tt>, or similar, as such
directories are also often included in wheels despite the clashes that will
result.</p>
<p>Do note that, when it comes to sdists, it’s perfectly fine to have a <tt class="docutils literal">tests/</tt>
etc. directory at the base of your project, as sdists themselves are not
installed, they’re just used to build wheels, which are what actually get
installed.</p>
</div>
<div class="section" id="top-level-readme-or-license-file-in-wheel">
<h2><a class="toc-backref" href="#contents">Top-Level <tt class="docutils literal">README</tt> or <tt class="docutils literal">LICENSE</tt> File in Wheel</a></h2>
<p>Similarly to the above mistake involving <tt class="docutils literal">tests/</tt>, it is also a bad idea to
include your project’s <tt class="docutils literal">README.rst</tt>/<tt class="docutils literal">README.md</tt> or <tt class="docutils literal">LICENSE</tt> file (or
<tt class="docutils literal">CHANGELOG</tt> or really anything that’s not a Python module or <tt class="docutils literal">*.pth</tt> file)
at the root of your wheel, as it will collide with the <tt class="docutils literal">README</tt>s and
<tt class="docutils literal">LICENSE</tt>s of other projects that do the same thing.  This mistake is
particularly common among projects built using <a class="reference external" href="https://python-poetry.org">Poetry</a>, where the <tt class="docutils literal">include</tt> option can be used to add
any file directly into both the sdist and wheel.</p>
<p>If you do want to include your <tt class="docutils literal">README</tt> or <tt class="docutils literal">LICENSE</tt> in your wheel, the
correct way is as follows:</p>
<ul>
<li><p class="first">For <tt class="docutils literal">README</tt>, the file’s contents should already be used as the project’s
(long) description, in which case the contents are already included in the
project metadata, which is stored in <tt class="docutils literal"><span class="pre">PKG-INFO</span></tt> (for sdists) or
<tt class="docutils literal"><span class="pre">*.dist-info/METADATA</span></tt> (for wheels), and thus there is no need to include
the <tt class="docutils literal">README</tt> as a separate file.  If you need to be able to retrieve the
<tt class="docutils literal">README</tt>’s contents at runtime, this can be done by using
<a class="reference external" href="https://docs.python.org/3/library/importlib.metadata.html"><tt class="docutils literal">importlib.metadata</tt></a> or similar to fetch the project’s description.</p>
</li>
<li><p class="first">Licenses and related files belong inside a wheel’s <tt class="docutils literal"><span class="pre">*.dist-info</span></tt> directory.
If using setuptools with wheel 0.32 or higher, licenses can be placed there
by passing them to the <tt class="docutils literal">[metadata]license_files</tt> option in <tt class="docutils literal">setup.cfg</tt>;
<a class="reference external" href="https://wheel.readthedocs.io/en/stable/user_guide.html#including-license-files-in-the-generated-wheel-file">see the wheel documentation for more information</a>.</p>
<p>At time of writing, Poetry does not support adding license files to a wheel’s
<tt class="docutils literal"><span class="pre">*.dist-info</span></tt> directory, but <a class="reference external" href="https://github.com/python-poetry/poetry/pull/1367">PR #1367</a> would change that.</p>
</li>
</ul>
</div>
<div class="section" id="project-description-doesn-t-render">
<h2><a class="toc-backref" href="#contents">Project Description Doesn’t Render</a></h2>
<p>The Python Package Index (PyPI) supports project (long) descriptions written in
three possible formats: <a class="reference external" href="https://docutils.sourceforge.io/rst.html">reStructuredText</a> (the default if no format is
specified), Markdown (either <a class="reference external" href="https://github.github.com/gfm/">GitHub Flavored Markdown</a> or <a class="reference external" href="https://commonmark.org">CommonMark</a>), and
plain text.  Markdown and plain text are lenient formats; anything you write in
them is valid.  However, documents written in reStructuredText can be
malformed, producing errors &amp; warning messages when rendered.  When a project
with a malformed reStructuredText description (either because it uses
reStructuredText incorrectly or because it’s actually Markdown that wasn’t
declared as Markdown) is uploaded to PyPI, PyPI does one of the following two
things:</p>
<ul class="simple">
<li>If the project does not declare a <tt class="docutils literal"><span class="pre">Content-Type</span></tt> for its malformed
description, PyPI will fall back to displaying the source of the description
as though it were plain text.</li>
<li>If the project explicitly declares the malformed description’s
<tt class="docutils literal"><span class="pre">Content-Type</span></tt> as reStructuredText (i.e., as the MIME type <tt class="docutils literal"><span class="pre">text/x-rst</span></tt>),
PyPI will reject the upload.</li>
</ul>
<p>Neither situation is desirable, but at least the latter gives you the chance to
correct your project description before it’s released on PyPI, while the former
situation means your project’s PyPI page shows an ugly, unprofessional-looking
description until you make a new release.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When using setuptools, you may find that your project’s long description
has been mangled somewhat, with a bunch of “Field: Value” entries added to
the bottom and various information missing from the listing on the left
side of the PyPI project page.  This happens whenever you include a newline
in your project’s summary/short description, thereby triggering <a class="reference external" href="https://github.com/pypa/setuptools/issues/1390">setuptools
bug #1390</a>.  Always make sure that no newlines end up passed to the
<tt class="docutils literal">description</tt> argument of <tt class="docutils literal">setup()</tt>!</p>
</div>
<p>There are two things you can do to avoid uploading a project with a malformed
description to PyPI:</p>
<ul id="set-content-type">
<li><p class="first">Set your description’s <tt class="docutils literal"><span class="pre">Content-Type</span></tt> appropriately.  If you’re using
reStructuredText, this will cause PyPI to reject any uploads with malformed
project descriptions.  If you’re not using reStructuredText, setting the
<tt class="docutils literal"><span class="pre">Content-Type</span></tt> is necessary in order for your description to be rendered
properly.</p>
<p>The content types for the supported formats are as follows:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name" colspan="2">reStructuredText:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body"><tt class="docutils literal"><span class="pre">text/x-rst</span></tt></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Markdown (GitHub Flavored Markdown):</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body"><tt class="docutils literal">text/markdown</tt> or <tt class="docutils literal">text/markdown; variant=GFM</tt></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Markdown (CommonMark):</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body"><tt class="docutils literal">text/markdown; variant=CommonMark</tt></td>
</tr>
<tr class="field"><th class="field-name">Plain text:</th><td class="field-body"><tt class="docutils literal">text/plain</tt></td>
</tr>
</tbody>
</table>
<p>If your project is built using setuptools, you set the description’s
<tt class="docutils literal"><span class="pre">Content-Type</span></tt> by setting the <tt class="docutils literal">long_description_content_type</tt> argument to
<tt class="docutils literal">setup()</tt> to the appropriate value from the above table.  Note that this
requires setuptools 36.4.0 or higher in order to work (or 38.3.0 or higher if
you’re setting it in <tt class="docutils literal">setup.cfg</tt>).</p>
</li>
<li><p class="first">Run the <tt class="docutils literal">twine check</tt> command from <a class="reference external" href="https://twine.readthedocs.io">twine</a> on your sdist and wheel before
uploading them.  This command checks whether your project description can be
rendered on PyPI before you actually upload it.</p>
</li>
</ul>
</div>
<div class="section" id="project-description-not-included">
<h2><a class="toc-backref" href="#contents">Project Description Not Included</a></h2>
<p>It’s just embarassing when this happens.  A project without a long description
just looks completely pointless; how am I supposed to know what it does or how
to use it?  Sadly, too many projects on PyPI lack long descriptions.  Did the
developer not care enough to write even a README?  Did the developer forget to
use the README as the long description or not know they had to?</p>
<p>If your project’s got a README — and really, a project that doesn’t have one
isn’t ready to be released — and it’s written in reStructuredText, Markdown, or
plain text (a safe bet), you can (and should) use it as your project’s long
description by adding the following or similar to your <tt class="docutils literal">setup.py</tt>:</p>
<pre class="code python literal-block">
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;README.extension&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
    <span class="n">long_description</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="n">setup</span><span class="p">(</span>
    <span class="o">...</span>
    <span class="n">long_description</span> <span class="o">=</span> <span class="n">long_description</span><span class="p">,</span>
    <span class="o">...</span>
<span class="p">)</span>
</pre>
<p>If your project isn’t in reStructuredText, you’ll also need to set
<tt class="docutils literal">long_description_content_type</tt> to the appropriate value in <a class="reference internal" href="#set-content-type">the table above</a> so that the description renders properly on PyPI.</p>
</div>
<div class="section" id="python-package-not-included-in-wheel">
<h2><a class="toc-backref" href="#contents">Python Package Not Included in Wheel</a></h2>
<p>If not having a description is embarassing, not having any code in your wheel
is crippling.  With a wheel like this, when people install your project, they
get nothing!  That’s certainly not what you want, is it?</p>
<p>Possible reasons why this can happen include:</p>
<ul class="simple">
<li>You’re using <tt class="docutils literal">find_packages()</tt> to autolocate your project’s packages, but
you failed to add an <tt class="docutils literal">__init__.py</tt> file to the top-level package (and
possibly also some subpackages).  Solution: Add that <tt class="docutils literal">__init__.py</tt>.<ul>
<li>If your intention is to leave out the <tt class="docutils literal">__init__.py</tt> file in order to
create a namespace package, you’ll need to use <a class="reference external" href="https://setuptools.readthedocs.io/en/latest/setuptools.html#find-namespace-packages"><tt class="docutils literal">find_namespace_packages()</tt></a>
instead.</li>
</ul>
</li>
<li>Your project’s code is a single Python module (as opposed to a directory of
modules) and you’re using the <tt class="docutils literal">packages</tt> argument to <tt class="docutils literal">setup()</tt> and/or
<tt class="docutils literal">find_packages()</tt> in an attempt to declare the module to setuptools.  This
is wrong.  When your project is a single Python module, instead of the
<tt class="docutils literal">packages</tt> argument, you need to use the <tt class="docutils literal">py_modules</tt> argument.  Set
<tt class="docutils literal">py_modules</tt> to a list of strings where each string is the name of a
top-level Python module <em>without</em> the “<tt class="docutils literal">.py</tt>” extension.  (Usually, you’ll
just have one module to list here.)  You can’t use <tt class="docutils literal">find_packages()</tt> for
this.</li>
</ul>
<p id="pkg-test">If your project includes any tests (which it should), you can implicitly test
that your wheel contains your project code by testing against the installed
version of your project instead of the copy in your repository.  To do this,
<tt class="docutils literal">pip</tt>-install your package (ideally in a virtualenv, and not in
development/editable mode!) before running the tests and ensure that the
directory containing the repository copy of your code is not in <tt class="docutils literal">sys.path</tt>
when the tests run.  <a class="reference external" href="https://tox.readthedocs.io">Tox</a> can help with the first part.  The second part
depends in part on your test framework, but you can guarantee your tests aren’t
picking up the local copy by switching to a <tt class="docutils literal">src/</tt> layout (<a class="reference internal" href="#src">see above</a>).  With these two things in place, your tests will be forced to import
your package from <tt class="docutils literal"><span class="pre">site-packages</span></tt>, where it’s in a form determined by the
contents of the project’s wheel.  If your wheel is missing code and your tests
try to import that code, you’ll get an error when the tests run, and you’ll
know that you need to fix something.</p>
</div>
<div class="section" id="subpackages-not-included-in-wheel">
<h2><a class="toc-backref" href="#contents">Subpackages Not Included in Wheel</a></h2>
<p>Sometimes, a project’s top-level package directory and the files within get
included in a wheel, but the subdirectories and their contents get left out.
Admittedly, I don’t know how common this is, as you can’t determine whether a
wheel is missing subpackages just by looking at its contents unless you also
know what’s in the project’s repository.  However, it’s an easy thing to mess
up, and various packaging articles I’ve read frequently make reference to this
problem, so it can’t be that uncommon.</p>
<p>There are two major reasons why one or more of your Python package’s
subpackages might be omitted from wheels:</p>
<ul>
<li><p class="first">You’re passing a list of packages to the <tt class="docutils literal">packages</tt> argument to <tt class="docutils literal">setup()</tt>
and the list fails to include every package &amp; subpackage in your project.  If
your project’s top-level package is named “<tt class="docutils literal">foo</tt>” and it contains two
subdirectories named “<tt class="docutils literal">bar</tt>” and “<tt class="docutils literal">baz</tt>” that contain (directly or
indirectly) Python source files, then <tt class="docutils literal">bar</tt> and <tt class="docutils literal">baz</tt> are subpackages of
<tt class="docutils literal">foo</tt>, and they all need to be included in the packages list:</p>
<pre class="code python literal-block">
<span class="n">packages</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="s2">&quot;foo.bar&quot;</span><span class="p">,</span> <span class="s2">&quot;foo.baz&quot;</span><span class="p">]</span>
</pre>
<p>If <tt class="docutils literal">baz</tt> contains another directory named “<tt class="docutils literal">glarch</tt>” that contains more
Python source files, then <code class="py python"><span class="s2">&quot;foo.baz.glarch&quot;</span></code> needs to be included in the
list as well, and so on.</p>
<p>Note that directories that only contain data files and no Python source files
do not count as packages and should not be passed to the <tt class="docutils literal">packages</tt>
argument.  They are instead <em>package data</em> directories; <a class="reference internal" href="#package-data">see below</a> for advice on dealing with them.</p>
<p>Of course, a simple alternative to listing every package explicitly is to
just use the <tt class="docutils literal">find_packages()</tt> function, which brings us to cause #2 …</p>
</li>
<li><p class="first">You’re using <tt class="docutils literal">find_packages()</tt> to autolocate your project’s packages, but
you failed to add an <tt class="docutils literal">__init__.py</tt> file to one or more subpackages.
<tt class="docutils literal">find_packages()</tt> only counts something as a package if it contains an
<tt class="docutils literal">__init__.py</tt> file, so you need to include that file in any subdirectory of
your Python package that contains Python source files or contains a directory
that contains Python source files.</p>
</li>
</ul>
<p>As with omitting the package entirely from the wheel, <a class="reference internal" href="#pkg-test">proper testing practices</a> can let you know when this happens in advance of a release.</p>
</div>
<div class="section" id="package-data-not-included-in-wheel">
<span id="package-data"></span><h2><a class="toc-backref" href="#contents">Package Data Not Included in Wheel</a></h2>
<p>Sometimes, you want to include non-Python data or resource files inside a
Python package so that they can be used at runtime, but sometimes those files
fail to end up in the final wheel.  Like the omission of subpackages, it’s hard
to know just how common this is, but even experienced Python programmers have
made mistakes with package data configurations on occasion.  This also happens
to be yet another situation where <a class="reference internal" href="#pkg-test">testing the installed version of your code</a> will help you out.</p>
<p>Setuptools provides two ways to specify package data.  The first way is to
configure <tt class="docutils literal">MANIFEST.in</tt> so that the desired package data files are included
in the sdist and then pass <code class="py python"><span class="n">include_package_data</span><span class="o">=</span><span class="kc">True</span></code> to <tt class="docutils literal">setup()</tt> so
that all files inside the Python package that are included in the sdist are
also included in the wheel.  Pretty much the only way to make a mistake here is
by not matching all of the files you want with <tt class="docutils literal">MANIFEST.in</tt> commands;
<a class="reference external" href="https://packaging.python.org/guides/using-manifest-in/">consult this reference</a> if you run into problems.</p>
<p>The second way to specify package data is with the <tt class="docutils literal">package_data</tt> argument to
<tt class="docutils literal">setup()</tt>.  This argument takes a <tt class="docutils literal">dict</tt> mapping package &amp; subpackage names
to lists of glob patterns defining what package data files to include in sdists
&amp; wheels.  The biggest gotcha with this method is the fact that each glob
pattern is only applied to the corresponding package and not any of its
subpackages.  This means that, with a <tt class="docutils literal">package_data</tt> like this:</p>
<pre class="code python literal-block">
<span class="n">package_data</span><span class="o">=</span><span class="p">{</span>
    <span class="s2">&quot;package&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;*.txt&quot;</span><span class="p">],</span>
<span class="p">}</span>
</pre>
<p><tt class="docutils literal">*.txt</tt> files in <tt class="docutils literal">package</tt> will be recognized as package data and included
in the sdist &amp; wheel, but <tt class="docutils literal">*.txt</tt> files in <tt class="docutils literal">package.subpackage</tt> will not.
To include <tt class="docutils literal">*.txt</tt> files in <tt class="docutils literal">package.subpackage</tt>, you’ll need to either add
a <code class="py python"><span class="s2">&quot;package.subpackage&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;*.txt&quot;</span><span class="p">]</span></code> entry to <tt class="docutils literal">package_data</tt> or else
include all <tt class="docutils literal">*.txt</tt> files in all packages &amp; subpackages by using the empty
string as a key: <code class="py python"><span class="s2">&quot;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;*.txt&quot;</span><span class="p">]</span></code>.</p>
<p>No matter which method you choose, be sure to exclude <tt class="docutils literal">*.pyc</tt> files from
consideration as package data; <a class="reference internal" href="#pyc">see the next section</a> for why.</p>
<p>Note that if you combine the two ways to specify package data by setting
<code class="py python"><span class="n">include_package_data</span><span class="o">=</span><span class="kc">True</span></code> while also using <tt class="docutils literal">package_data</tt>, then the
files matched by <tt class="docutils literal">package_data</tt> will not be included in the sdist unless
they’re already included by <tt class="docutils literal">MANIFEST.in</tt>.  Getting this wrong can cause
wheels built from an sdist to lack package data files.</p>
<p>See <a class="reference external" href="https://setuptools.readthedocs.io/en/latest/setuptools.html#including-data-files">“Including Data Files” in the setuptools documentation</a> for more
information.</p>
</div>
<div class="section" id="pyc-files-included-in-wheel">
<span id="pyc"></span><h2><a class="toc-backref" href="#contents"><tt class="docutils literal">*.pyc</tt> Files Included in Wheel</a></h2>
<p>When a Python source file is imported into a Python process, a <tt class="docutils literal">*.pyc</tt> file
containing compiled bytecode is created and (in Python 3) stored in a
<tt class="docutils literal">__pycache__/</tt> directory so that future imports of the same file will be
faster.  These <tt class="docutils literal">*.pyc</tt> files use a format that is specific to the OS, Python
implementation, and Python version, and so it is pointless to share them.  They
do not belong in wheels (especially considering that pip already generates a
host-appropriate set of <tt class="docutils literal">*.pyc</tt> files when it installs a wheel), and yet too
often people distribute wheels with <tt class="docutils literal">*.pyc</tt> files in them.</p>
<p>Probably the most common reason why <tt class="docutils literal">*.pyc</tt> files end up in wheels is that
the project’s <tt class="docutils literal">MANIFEST.in</tt> file contains “<tt class="docutils literal">graft packagename</tt>”, “<tt class="docutils literal">graft
src</tt>”, or a similar line and <code class="py python"><span class="n">include_package_data</span><span class="o">=</span><span class="kc">True</span></code> is passed to
<tt class="docutils literal">setup()</tt>.  With this configuration, all files in the Python package
directory when the wheel is built are added to the wheel.  To prevent <tt class="docutils literal">*.pyc</tt>
files from being added, “<tt class="docutils literal"><span class="pre">global-exclude</span> *.pyc</tt>” or similar needs to be added
to the <tt class="docutils literal">MANIFEST.in</tt>, ideally at the end of the file.</p>
<p>Alternatively, if the project specifies its package data with the
<tt class="docutils literal">package_data</tt> argument, including a <tt class="docutils literal">&quot;*&quot;</tt> pattern in the <tt class="docutils literal">package_data</tt>
mapping is liable to cause <tt class="docutils literal">*.pyc</tt> files to be included in the wheel.  They
should be excluded from package data by setting <tt class="docutils literal">exclude_package_data</tt> to a
<tt class="docutils literal">dict</tt> that maps the appropriate keys to <code class="py python"><span class="p">[</span><span class="s2">&quot;*.pyc&quot;</span><span class="p">]</span></code>.</p>
</div>
<div class="section" id="rebuilding-wheels-without-deleting-build">
<span id="rebuild-noclean"></span><h2><a class="toc-backref" href="#contents">Rebuilding Wheels without Deleting <tt class="docutils literal">build/</tt></a></h2>
<p>You should have noticed when building your project’s wheels that, in addition
to creating a <tt class="docutils literal">dist/</tt> directory containing the output wheel, setuptools also
creates a <tt class="docutils literal">build/</tt> directory containing a couple directories and a copy of
your code.  This <tt class="docutils literal">build/</tt> directory is an intermediate stage in the process
of assembling a wheel; you should exclude it from version control and feel free
to delete it at any time.  In fact, it’s a good idea to delete it before
running the command to create a wheel, <em>especially</em> if you’ve moved or renamed
any files or directories in your code since the last time you built a wheel.</p>
<p>Consider the following scenario:</p>
<ul class="simple">
<li>You build a wheel for your project, and you leave the <tt class="docutils literal">build/</tt> directory
lying around afterwards.</li>
<li>You move, rename, and/or delete some files in your Python package, perhaps
even renaming the package itself.</li>
<li>You build the wheel again — and when you do so, setuptools copies your new
package tree into <tt class="docutils literal">build/</tt>.  Files that existed the last time the wheel was
built overwrite their old copies in <tt class="docutils literal">build/</tt> successfully, but any old
paths that have since been removed remain in <tt class="docutils literal">build/</tt>.</li>
<li>As a result, your wheel ends up containing a mixture of your new and old
code.  In the case where you renamed your package, the wheel will contain
both the pre-rename package and the post-rename package next to each other in
their entirety, so you wheel has double the code with half of it under the
wrong name.</li>
</ul>
<p>This is clearly not desirable.  The solution is to always delete the <tt class="docutils literal">build/</tt>
directory before building a wheel, such as by cleaning your repository with
<tt class="docutils literal">git clean</tt> or similar, or by running <tt class="docutils literal">python setup.py clean <span class="pre">--all</span></tt> <a class="footnote-reference" href="#id10" id="id7">[1]</a>.</p>
</div>
<div class="section" id="pinning-project-requirements-to-exact-versions">
<h2><a class="toc-backref" href="#contents">Pinning Project Requirements to Exact Versions</a></h2>
<p>There are a number of projects on PyPI where the dependencies are all of the
form “<tt class="docutils literal">foo == 1.2.3</tt>”, as opposed to “<tt class="docutils literal">foo &gt;= 1.2.3</tt>”, “<tt class="docutils literal">foo &gt;= 1.2, &lt;
2</tt>”, or just “<tt class="docutils literal">foo</tt>”.  This is called <em>pinning</em> requirements.  This makes
sense when you’re developing a Python application that will be the primary
project in its environment (in which case you often won’t be uploading it to
PyPI), but it doesn’t make sense when you’re distributing a library for others
to use alongside other arbitrary libraries.  For one thing, your library is
almost certainly going to work just as well with version 1.2.4 of foo <a class="footnote-reference" href="#id11" id="id8">[2]</a>, so
why leave it out?  For another thing, if someone wants to use your library with
its pinned <tt class="docutils literal">foo</tt> requirement alongside other libraries, sooner or later
they’ll run into a situation where they’re installing both it and another
project that requires a different version of <tt class="docutils literal">foo</tt> (maybe even differing by
one micro version!), and then problems ensue <a class="footnote-reference" href="#id12" id="id9">[3]</a>.  True, clashes between
version dependencies in disparate projects can’t be avoided 100%, but they can
be made to occur far less often if projects require generous version ranges
instead of specific versions.</p>
<p>A general way to construct a decent version range for a requirement is to first
determine the lowest version of the dependency that has all of the features you
need and then use this version as the requirement’s lower bound.  If the
dependency follows or approximates <a class="reference external" href="https://semver.org">semantic versioning</a>,
use the next major version (or the next minor version, if pre-v1) as the
(exclusive) upper bound.  If the dependency uses something like calendar
versioning instead, things are less clear, but my preference is to leave out
the upper bound and afterwards keep abreast of any future changes to the
dependency.  If any versions of the dependency inside the requirement’s bounds
have known bugs that interfere with your project’s behavior, feel free to
exclude them by adding specifiers of the form <tt class="docutils literal">!= X.Y.Z</tt> to the version
range.</p>
</div>
<div class="section" id="conclusion">
<h2><a class="toc-backref" href="#contents">Conclusion</a></h2>
<p>I’m very disappointed in all of you for making these mistakes so often, and I
hope this article makes at least one Python package less broken.  (I’d prefer
it if all broken packages were less broken, but I know not to get my hopes up.)</p>
<p>Admittedly, most of these mistakes are due to users not using or understanding
setuptools properly (aside from a Poetry antipattern that sneaked in at #2).
Though flit and Poetry may promise to fix setuptools’ usability issues, people
keep on using setuptools, and it keeps on outsmarting them.  Hopefully sites
like the <a class="reference external" href="https://packaging.python.org">Python Packaging User Guide</a> eventually expand &amp; become mature
enough in the near future to cover — if not all the edge cases — at least the
best practices that avoid them.</p>
</div>
<div class="section" id="footnotes">
<h2><a class="toc-backref" href="#contents">Footnotes</a></h2>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[1]</a></td><td>Setuptools is currently trying to get people to move away from
<tt class="docutils literal">setup.py</tt> commands, so <tt class="docutils literal">setup.py clean</tt> will be discouraged — and
probably deprecated — at some indeterminate point in the future.  Until
that happens, though, don’t feel bad about using it if you need to.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[2]</a></td><td>Unless <tt class="docutils literal">foo</tt> is an unpredictable, compatibility-breaking mess, in
which case you should probably reconsider dependending on it.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[3]</a></td><td>Currently, pip handles conflicting version requirements with a warning
and picking one requirement to follow, but pip’s new dependency resolver
due out in October 2020 (already available if you pass the right flag to
pip) will react to such situations by searching for older versions of
the installation candidates with non-conflicting requirements, and if it
can’t find any, it errors out without installing anything.</td></tr>
</tbody>
</table>
</div>
</div>
    </article>
</section>
        </div>
    </div>

        <footer id="footer">
<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
    <img alt="Creative Commons License" style="border-width: 0; vertical-align: middle;" src="https://i.creativecommons.org/l/by/4.0/80x15.png" />
</a>

Copyright © 2020–2021 <a xmlns:cc="http://creativecommons.org/ns#"
href="https://github.com/jwodder" property="cc:attributionName"
rel="cc:attributionURL">John T. Wodder II</a>.  This site's content is licensed under a
<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative
Commons Attribution 4.0 International License</a>.
</footer>
</body>
</html>