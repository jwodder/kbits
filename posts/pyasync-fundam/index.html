<!DOCTYPE html>
<html lang="en">
<head>
    <title>Knowledge Bits — Python Asynchronous Programming Fundamentals</title>
    <meta charset="utf-8"/>
    <meta name="generator" content="Pelican (https://getpelican.com)"/>
    <link rel="stylesheet" href="https://jwodder.github.io/kbits/theme/css/main.css" type="text/css"/>
    <script type="text/javascript" id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    <link href="https://jwodder.github.io/kbits/feeds/posts.atom.xml" type="application/atom+xml" rel="alternate" title="Knowledge Bits Full Atom Feed" />
    <link href="https://jwodder.github.io/kbits/feeds/posts.rss" type="application/rss+xml" rel="alternate" title="Knowledge Bits Full RSS Feed" />
    
        <meta name="description" content="Python introduced asynchronous programming capabilities in version 3.4 in 2014, with further notable improvements in almost every minor version since. However, to many Python programmers, this area of the language remains esoteric, misunderstood, and underutilized. This article aims to elucidate the fundamental concepts of asynchronous programming as part of the first step towards mastery."/>
        <meta name="tags" content="Python"/>
        <meta name="tags" content="async"/>
        <meta name="author" content="John T. Wodder II"/>
        <meta name="keywords" content="Python,async"/>
</head>

<body>
    <div id="kbits-theme-topbar">
        <header>
            <span class="sitename">
                <a href="https://jwodder.github.io/kbits/">Knowledge Bits</a>
            </span>
            <span class="sitesubtitle">References I wish I&#39;d already found</span>
        </header>
    </div>

    <div class="mainrow">
        <div id="kbits-theme-navbar">
            <nav>
                <ul>
                    <li><a href="https://jwodder.github.io/kbits/categories/">Categories</a></li>
                    <li><a href="https://jwodder.github.io/kbits/tags/">Tags</a></li>
                    <li><a href="https://github.com/jwodder/kbits">Site Repository</a></li>
                </ul>
            </nav>
                <div class="postfeeds">
                    <img src="https://jwodder.github.io/kbits/theme/images/rss.svg" width="16" height="16"/>
                    <a href="https://jwodder.github.io/kbits/feeds/posts.atom.xml">Atom</a>
                    ·
                    <a href="https://jwodder.github.io/kbits/feeds/posts.rss">RSS</a>
                </div>
        </div>
        <div id="kbits-theme-content">
<section>
    <article>
        <header>
            <h1>
                <a href="https://jwodder.github.io/kbits/posts/pyasync-fundam/" rel="bookmark"
                    title="Permalink to Python Asynchronous Programming Fundamentals">Python Asynchronous Programming Fundamentals</a>
            </h1>
        </header>
        <footer>
            <table class="docinfo" border="1">
                <tr>
                    <th>Posted:</th>
                    <td><time datetime="2022-05-29T00:00:00-04:00" pubdate="1">2022-05-29</time></td>
                </tr>
                <tr>
                    <th>Modified:</th>
                    <td><time datetime="2022-07-17T00:00:00-04:00">2022-07-17</time></td>
                </tr>
                <tr>
                    <th>Author:</th>
                    <td>
<span class="fn">John T. Wodder II</span>                    </td>
                </tr>
                <tr>
                    <th>Category:</th>
                    <td><a href="https://jwodder.github.io/kbits/categories/programming/">Programming</a></td>
                </tr>
                <tr>
                    <th>Tags:</th>
                    <td>
<a href="https://jwodder.github.io/kbits/tags/python/">Python</a>, <a href="https://jwodder.github.io/kbits/tags/async/">async</a>                    </td>
                </tr>
                <tr>
                    <th>Page Source:</th>
                    <td><a href="https://github.com/jwodder/kbits/blob/master/src/posts/pyasync-fundam.rst">[link]</a></td>
                </tr>
            </table>
        </footer>
        <div><p>Python introduced asynchronous programming capabilities in version 3.4 in 2014,
with further notable improvements in almost every minor version since.
However, to many Python programmers, this area of the language remains
esoteric, misunderstood, and underutilized.  This article aims to elucidate the
fundamental concepts of asynchronous programming as part of the first step
towards mastery.</p>
<p>There won’t be many code samples in this article, but reading it should make it
easier to grok <a class="reference external" href="https://docs.python.org/3/library/asyncio.html">the asyncio documentation</a> and figure out how to piece things
together.</p>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul>
<li><p class="first"><a class="reference internal" href="#high-level-overview" id="toc-entry-1">High-Level Overview</a></p>
</li>
<li><p class="first"><a class="reference internal" href="#definitions" id="toc-entry-2">Definitions</a></p>
</li>
<li><p class="first"><a class="reference internal" href="#syntax" id="toc-entry-3">Syntax</a></p>
<ul>
<li><p class="first"><a class="reference internal" href="#type-annotations" id="toc-entry-4">Type Annotations</a></p>
</li>
<li><p class="first"><a class="reference internal" href="#special-methods" id="toc-entry-5">Special Methods</a></p>
</li>
<li><p class="first"><a class="reference internal" href="#historical-note-generator-based-coroutines" id="toc-entry-6">Historical Note: Generator-Based Coroutines</a></p>
</li>
</ul>
</li>
<li><p class="first"><a class="reference internal" href="#running-more-than-one-coroutine-at-once" id="toc-entry-7">Running More than One Coroutine at Once</a></p>
</li>
<li><p class="first"><a class="reference internal" href="#exception-handling" id="toc-entry-8">Exception Handling</a></p>
</li>
<li><p class="first"><a class="reference internal" href="#example-code" id="toc-entry-9">Example Code</a></p>
</li>
<li><p class="first"><a class="reference internal" href="#asynchronous-programming-vs-threads" id="toc-entry-10">Asynchronous Programming vs. Threads</a></p>
</li>
<li><p class="first"><a class="reference internal" href="#async-version-history" id="toc-entry-11">Async Version History</a></p>
</li>
<li><p class="first"><a class="reference internal" href="#alternative-async-implementations" id="toc-entry-12">Alternative Async Implementations</a></p>
</li>
</ul>
</div>
<div class="section" id="high-level-overview">
<h2><a class="toc-backref" href="#contents">High-Level Overview</a></h2>
<p>Asynchronous programming provides a way to interleave execution of multiple
functions (<a class="reference internal" href="#coroutines">coroutines</a>) at once; at any given point, only one of the functions
is actually doing operations, while the others are waiting for things like
blocking I/O to complete (or, if the I/O has already completed, they’re waiting
for the current coroutine to be suspended so that they get a chance to resume).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In the Python standard library and all third-party async libraries that I
am aware of, the kinds of low-level operations that one can ultimately
suspend execution waiting for are almost exclusively I/O-related.  If
you’re seeking to add concurrency to CPU-bound code (e.g., anything
involving number crunching), you are likely to be better off using
multiprocessing instead.</p>
</div>
<p>Specifically, whenever execution of a currently-running coroutine reaches an
<tt class="docutils literal">await</tt> expression, the coroutine may be suspended, and another
previously-suspended coroutine may resume execution if what it was suspended on
has since returned a value.  Suspension can also happen when an <tt class="docutils literal">async for</tt>
block requests the next value from an asynchronous iterator or when an <tt class="docutils literal">async
with</tt> block is entered or exited, as these operations use <tt class="docutils literal">await</tt> under the
hood.</p>
<p>Note that, although multiple coroutines can be processed at once, effectively
finishing in any order, operations within a single coroutine continue to be
executed in the order they’re written.  For example, given the following code:</p>
<pre class="code python literal-block">
<span class="k">async</span> <span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="o">...</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">g</span><span class="p">():</span>
    <span class="o">...</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">amain</span><span class="p">():</span>
    <span class="k">await</span> <span class="n">f</span><span class="p">()</span>
    <span class="k">await</span> <span class="n">g</span><span class="p">()</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">amain</span><span class="p">())</span>
</pre>
<p>When <tt class="docutils literal">await f()</tt> is reached, <tt class="docutils literal">amain()</tt> will be suspended until <tt class="docutils literal">f()</tt> is
finished, and only after that will execution proceed to the next line, starting
coroutine <tt class="docutils literal">g()</tt>.  If you want to execute <tt class="docutils literal">f()</tt> and <tt class="docutils literal">g()</tt> concurrently,
you need to use <a class="reference external" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task"><tt class="docutils literal">asyncio.create_task()</tt></a>, <a class="reference external" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.gather"><tt class="docutils literal">asyncio.gather()</tt></a>, or similar.  See
<a class="reference external" href="https://hynek.me/articles/waiting-in-asyncio/">this article</a> for more details.</p>
<p>In general, coroutines can only be called or scheduled by other coroutines.  To
run a “top-level” coroutine from inside synchronous code (i.e., either inside a
non-coroutine function or at module level), the simplest &amp; preferred way is to
use the <a class="reference external" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.run"><tt class="docutils literal">asyncio.run()</tt></a> function introduced in Python 3.7.  Code meant to run on
older Pythons must use the lower-level <a class="reference external" href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.run_until_complete"><tt class="docutils literal">loop.run_until_complete()</tt></a> instead,
along with other loop methods for cleanup.</p>
</div>
<div class="section" id="definitions">
<h2><a class="toc-backref" href="#contents">Definitions</a></h2>
<p><em>Asynchronous programming</em> features the execution of multiple tasks
concurrently, with one task being run while waiting for others to complete.
Asynchronous programming in Python is an example of <em>cooperative multitasking</em>
[<a class="reference external" href="https://en.wikipedia.org/wiki/Cooperative_multitasking">wiki</a>], as it requires the running coroutines to cooperate and yield control
on their own; if the current coroutine goes for a long time without calling
<tt class="docutils literal">await</tt>, execution will remain on that coroutine all the while, and all other
coroutines in the thread will remain in a suspended state.  This is contrast to
the <em>preemptive multitasking</em> [<a class="reference external" href="https://en.wikipedia.org/wiki/Preemption_(computing)">wiki</a>] of multithreaded and multiprocess
programs, where the Python interpreter or OS scheduler decides on its own when
to switch between running contexts, with the points at which switches can occur
being difficult or impossible to predict in general.</p>
<p id="coroutines">A <em>coroutine function</em> is a function defined with <tt class="docutils literal">async def</tt> instead of just
<tt class="docutils literal">def</tt>.  (In the context of asynchronous programming, a function defined with
just <tt class="docutils literal">def</tt> is called a <em>synchronous function</em>.)  Only coroutine functions can
contain <tt class="docutils literal">await</tt>, <tt class="docutils literal">async for</tt>, and <tt class="docutils literal">async with</tt> constructs, and, as of
Python 3.10, they cannot contain <tt class="docutils literal">yield from</tt> constructs.</p>
<ul>
<li><p class="first">Note that just calling a coroutine function does not cause it to start
running; you need to either schedule it for concurrent execution with
<a class="reference external" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task"><tt class="docutils literal">asyncio.create_task()</tt></a> or similar or else <tt class="docutils literal">await</tt> on it directly.</p>
</li>
</ul>
<p>A <em>coroutine object</em> is the result of calling a coroutine function.  This is
not the value <tt class="docutils literal">return</tt>ed (or <tt class="docutils literal">raise</tt>d) by the function; rather, it is a
pending computation that can be suspended &amp; resumed at any point that the
coroutine function uses <tt class="docutils literal">await</tt>, <tt class="docutils literal">async for</tt>, or <tt class="docutils literal">async with</tt>.  The
actual <tt class="docutils literal">return</tt> value or exception is obtained either by awaiting on the
coroutine object (possibly wrapped in a task and/or something like
<a class="reference external" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.gather"><tt class="docutils literal">asyncio.gather()</tt></a>) from within another coroutine function or by running it as a
“top-level” entry point using <tt class="docutils literal">asyncio.run()</tt> within synchronous code.</p>
<ul>
<li><p class="first">Asynchronous generators — coroutine functions that use <tt class="docutils literal">yield</tt> — are a bit
of an exception.  You do not <tt class="docutils literal">await</tt> the result of the function; instead,
you iterate through it using either <tt class="docutils literal">async for ... in <span class="pre">...:</span></tt> or <tt class="docutils literal">await
<span class="pre">anext(...)</span></tt>.</p>
</li>
<li><p class="first">Confusingly, both coroutine functions and coroutine objects can be referred
to as just “coroutines.”</p>
</li>
</ul>
<p>The actual scheduling of coroutine execution is managed by an <em>event loop</em>.  An
event loop is created by <a class="reference external" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.run"><tt class="docutils literal">asyncio.run()</tt></a> or <tt class="docutils literal">asyncio.new_event_loop()</tt>, handed
one or more coroutines and/or synchronous callbacks, and then set off to run
either forever or until completion of a “top-level” coroutine.  It’s the event
loop’s job to execute the current coroutine until it suspends on an <tt class="docutils literal">await</tt>,
after which it looks to see if any suspended coroutines are now done with their
suspension and either picks one to resume or, if none are ready, waits until
one is.</p>
<p id="awaitable">An <em>awaitable</em> is any value that the <tt class="docutils literal">await</tt> keyword can be applied to; this
includes coroutine objects, futures, future-likes, and tasks (see below).
Awaiting on an awaitable causes the current coroutine to be suspended until the
awaitable is ready to provide a value or raise an exception.</p>
<p>A <em>future</em> (class <a class="reference external" href="https://docs.python.org/3/library/asyncio-future.html#asyncio.Future"><tt class="docutils literal">asyncio.Future</tt></a>) is a low-level container for the result of
a computation (a value or exception) that starts out empty and is assigned a
value or exception later.  Awaiting on a future will suspend the current
coroutine until something else either stores a result in the future or cancels
it.</p>
<ul>
<li><p class="first">You may already be familiar with futures in the form of the <tt class="docutils literal">Future</tt> class
from the <a class="reference external" href="https://docs.python.org/3/library/concurrent.futures.html"><tt class="docutils literal">concurrent.futures</tt></a> module, which provides access to the results
of operations evaluated in other threads or processes.  The
<a class="reference external" href="https://docs.python.org/3/library/asyncio-future.html#asyncio.Future"><tt class="docutils literal">asyncio.Future</tt></a> class is similar in spirit, but has a different API.</p>
</li>
</ul>
<p>A <em>future-like</em> is an object with an <tt class="docutils literal">__await__()</tt> method, which must return
an iterator.  Awaiting on a future-like causes the current coroutine to be
suspended until the iterator is exhausted, at which point the <tt class="docutils literal">value</tt>
attribute of the terminating <tt class="docutils literal">StopIteration</tt> exception is returned as the
result of the <tt class="docutils literal">await</tt> expression.</p>
<p>A <em>task</em> (class <a class="reference external" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task"><tt class="docutils literal">asyncio.Task</tt></a>) represents a running coroutine.  Creating a
task from a coroutine object with <a class="reference external" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task"><tt class="docutils literal">asyncio.create_task()</tt></a> will cause the
coroutine to be scheduled for execution concurrently with other running
coroutines.  The task instance can later be awaited on to suspend the current
coroutine until the wrapped coroutine finishes executing, returning its result.</p>
<p>A running task can be <em>cancelled</em> by calling its <a class="reference external" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.cancel"><tt class="docutils literal">Task.cancel()</tt></a> method.  This
will cause the underlying coroutine to receive an <tt class="docutils literal">asyncio.CancelledError</tt>
exception the next time it <tt class="docutils literal">await</tt>s, likely putting an end to the task’s
execution.</p>
</div>
<div class="section" id="syntax">
<h2><a class="toc-backref" href="#contents">Syntax</a></h2>
<p>Asynchronous programming in Python takes place inside <a class="reference internal" href="#coroutines">coroutines</a>, functions
defined using <tt class="docutils literal">async def</tt> instead of just <tt class="docutils literal">def</tt>.  Within a coroutine, the
<tt class="docutils literal">await</tt> keyword can be applied to any <a class="reference internal" href="#awaitable">awaitable</a> expression (such as a call
to another coroutine) to suspend execution of the coroutine until the awaitable
has a value or exception ready, at which point the coroutine is resumed and the
<tt class="docutils literal">await</tt> expression returns that value or raises that exception.</p>
<p>Here’s a basic example you’ve seen in all the tutorials:</p>
<pre class="code python literal-block">
<span class="kn">import</span> <span class="nn">asyncio</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">waiter</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Before sleep&quot;</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;After sleep&quot;</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">waiter</span><span class="p">())</span>
</pre>
<p>This code prints a message, waits for a five-second sleep to elapse, and then
prints another message.  As written, it’s rather pointless; we’re only running
one coroutine at once, so there’s no advantage over using a synchronous
function with <tt class="docutils literal">time.sleep()</tt>.  Here’s something slightly more involved:</p>
<pre class="code python literal-block">
<span class="kn">import</span> <span class="nn">asyncio</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">operate</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Spending </span><span class="si">{</span><span class="n">time</span><span class="si">}</span><span class="s2"> seconds doing operations ...&quot;</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Operations done after </span><span class="si">{</span><span class="n">time</span><span class="si">}</span><span class="s2"> seconds!&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">amain</span><span class="p">():</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">operate</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">42</span><span class="p">),</span> <span class="n">operate</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">23</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="n">x</span><span class="si">=}</span><span class="s2">, </span><span class="si">{</span><span class="n">y</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">42</span>
    <span class="k">assert</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">23</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">amain</span><span class="p">())</span>
</pre>
<p>This code mocks spending time on two blocking operations in parallel.  If you
run the script (Python 3.8+ required) and time it, you’ll see that it only
takes about 5 seconds in total, and the 2-second task completes three seconds
before the 5-second one.  After both tasks are done, the final “Got x=42, y=23”
message is printed.</p>
<p>Besides <tt class="docutils literal">await</tt>, there are two other syntactical constructs specific to
coroutines: <tt class="docutils literal">async for ... in <span class="pre">...:</span></tt> (for iterating over asynchronous
iterables) and <tt class="docutils literal">async with <span class="pre">...:</span></tt> (for entering &amp; exiting asynchronous context
managers).  These work the same way as their non-<tt class="docutils literal">async</tt> counterparts, except
that the iterables and context managers in question need to support
asynchronous usage; for example, an <tt class="docutils literal">async for</tt> cannot iterate over a
<tt class="docutils literal">list</tt>, and an <tt class="docutils literal">async with</tt> cannot operate on an ordinary filehandle.
Similarly, a regular <tt class="docutils literal">for</tt> cannot be applied to an asynchronous iterator, and
a regular <tt class="docutils literal">with</tt> cannot be applied to, say, <tt class="docutils literal">asyncio.Lock</tt>.</p>
<p>Speaking of asynchronous iteration, this works pretty much how you’d expect: by
using <tt class="docutils literal">yield</tt> inside a coroutine, it becomes an asynchronous generator that
can be iterated over with <tt class="docutils literal">async for</tt> or <tt class="docutils literal">await <span class="pre">anext(...)</span></tt>.  Note that, in
contrast to non-generator coroutines, you do not apply <tt class="docutils literal">await</tt> to an
asynchronous generator.  For example, given this function:</p>
<pre class="code python literal-block">
<span class="k">async</span> <span class="k">def</span> <span class="nf">aiterator</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">i</span>
</pre>
<p>you use it like this:</p>
<pre class="code python literal-block">
<span class="k">async</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">aiterator</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre>
<p>No <tt class="docutils literal">await</tt> anywhere in the <tt class="docutils literal">async for</tt> loop.</p>
<p>Note that there is no way to get a value out of a coroutine without awaiting on
it (either directly or via something like <a class="reference external" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.gather"><tt class="docutils literal">asyncio.gather()</tt></a>); if a coroutine is
never awaited and never converted into a task, <tt class="docutils literal">asyncio</tt> will complain when
it is garbage-collected.  Moreover, <tt class="docutils literal">await</tt> (and <tt class="docutils literal">async for</tt> and <tt class="docutils literal">async
with</tt>) cannot be used outside of a coroutine; in order to start the awaiting
on a “top-level” coroutine, you need to use <a class="reference external" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.run"><tt class="docutils literal">asyncio.run()</tt></a>.</p>
<p>Note that the body of a coroutine isn’t required to contain any <tt class="docutils literal">await</tt>s or
similar, though if it doesn’t, there often isn’t much point in making it a
coroutine in the first place.  An exception is the <tt class="docutils literal">__aenter__()</tt> special
method of asynchronous context managers; usually, the body will just be
<tt class="docutils literal">return self</tt>, but it’s still required to define the method with <tt class="docutils literal">async
def</tt>.</p>
<div class="section" id="type-annotations">
<h3><a class="toc-backref" href="#contents">Type Annotations</a></h3>
<p>Adding type annotations to asynchronous code works the same way as for
synchronous code.  If an asynchronous <tt class="docutils literal">func()</tt> take an integer <tt class="docutils literal">x</tt> and
returns a string, you write its annotated signature as <tt class="docutils literal">async def func(x: int)
<span class="pre">-&gt;</span> str</tt>.  However, if you pass around an unawaited coroutine object (not
always the best idea), you annotate it as <tt class="docutils literal">Awaitable[T]</tt>, where <tt class="docutils literal">T</tt> is the
return type of the coroutine.</p>
<p>Async callables do not have their own type; they are instead annotated as
<tt class="docutils literal"><span class="pre">Callable[...,</span> Awaitable[T]]</tt>, where <tt class="docutils literal">T</tt> is the return type of the
coroutine function.</p>
<p>Asynchronous iterators, iterables, and context managers, though, do get their
own types: <tt class="docutils literal">AsyncIterator</tt>, <tt class="docutils literal">AsyncIterable</tt>, and
<tt class="docutils literal">typing.AsyncContextManager</tt>/<tt class="docutils literal">contextlib.AbstractAsyncContextManager</tt>.</p>
</div>
<div class="section" id="special-methods">
<h3><a class="toc-backref" href="#contents">Special Methods</a></h3>
<p class="rubric"><tt class="docutils literal">__aiter__()</tt> and <tt class="docutils literal">__anext__()</tt></p>
<p>These methods are used to implement asynchronous iterator &amp; iterable classes as
an alternative to writing asynchronous generator functions, analogously to how
a class can be defined with <tt class="docutils literal">__iter__()</tt> and <tt class="docutils literal">__next__()</tt> methods to
implement a synchronous iterator as an alternative to writing a generator
function.</p>
<p><tt class="docutils literal">__aiter__()</tt> must be a synchronous function that returns an object with
<tt class="docutils literal">__aiter__()</tt> and <tt class="docutils literal">__anext__()</tt> methods.  <tt class="docutils literal">__anext__()</tt> must be a
coroutine that either returns a value or raises a <tt class="docutils literal">StopAsyncIteration</tt>
exception.</p>
<p class="rubric"><tt class="docutils literal">__aenter__()</tt> and <tt class="docutils literal">__aexit__()</tt></p>
<p>These methods are used to implement asynchronous context managers.  They are
defined the same way as the <tt class="docutils literal">__enter__()</tt> and <tt class="docutils literal">__exit__()</tt> methods of
synchronous context managers, except that the asynchronous versions must be
coroutines.</p>
<p class="rubric"><tt class="docutils literal">__await__()</tt></p>
<p>This method is used to create a future-like class that can be awaited directly.
There is generally very little need to implement this, but we include it here
for completeness.</p>
<p><tt class="docutils literal">__await__()</tt> must be a synchronous function that returns an iterator.  This
iterator will be advanced each time the event loop checks to see if the
future-like is ready to return a value.  If the future-like is not ready, the
iterator must yield a special value (see below).  If the future-like is ready,
it must either <tt class="docutils literal">return</tt> a result or raise an exception; this result or
exception will then be the result of the <tt class="docutils literal">await</tt> expression acting on the
future-like.</p>
<p>The values that the iterator yields depend on what async implementation the
code is running under (See “<a class="reference internal" href="#alternative-async-implementations">Alternative Async Implementations</a>” below).  When
using the Python standard library’s <tt class="docutils literal">asyncio</tt>, you generally want to yield
<tt class="docutils literal">None</tt>.  When using trio, you need to yield an instance of one of several
private classes internal to trio.  When using curio, you need to yield a
<tt class="docutils literal">(&quot;trap_name&quot;, *trap_args)</tt> tuple instructing the kernel to invoke a special
“trap” function; yielding <tt class="docutils literal">(&quot;trap_sleep&quot;, 0)</tt> instructs the kernel to do
nothing special.</p>
<p>For example, if you want to implement your own <tt class="docutils literal">Future</tt> class for use with
<tt class="docutils literal">asyncio</tt>, you might start out writing it like so:</p>
<pre class="code python literal-block">
<span class="k">class</span> <span class="nc">MyFuture</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_set</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">valuse</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_set</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__await__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set</span><span class="p">:</span>
            <span class="k">yield</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
</pre>
</div>
<div class="section" id="historical-note-generator-based-coroutines">
<h3><a class="toc-backref" href="#contents">Historical Note: Generator-Based Coroutines</a></h3>
<p>When <tt class="docutils literal">asyncio</tt> was first introduced in Python 3.4, the <tt class="docutils literal">async</tt> and
<tt class="docutils literal">await</tt> keywords were not yet present.  Instead, coroutine functions were
created by applying the <tt class="docutils literal">&#64;asyncio.coroutine</tt> decorator to a normal generator
function, and awaiting was done using <tt class="docutils literal">yield from</tt>.  There were no
asynchronous iterators or asynchronous context managers in 3.4, either.  Even
after <tt class="docutils literal">async</tt> and <tt class="docutils literal">await</tt> were introduced in Python 3.5, the older
generator-based coroutines could not use them.</p>
<p>This style of writing coroutines was deprecated in Python 3.8 and removed
entirely in Python 3.11.</p>
</div>
</div>
<div class="section" id="running-more-than-one-coroutine-at-once">
<h2><a class="toc-backref" href="#contents">Running More than One Coroutine at Once</a></h2>
<p>Now for the part you’ve been waiting for, and the part that makes asynchronous
programming worth it: actually running multiple functions concurrently.</p>
<p>The simplest way to start running another coroutine concurrently is to pass a
coroutine object to <a class="reference external" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task"><tt class="docutils literal">asyncio.create_task()</tt></a>; this schedules the coroutine for
execution, but it won’t actually start running until the next time the current
coroutine calls <tt class="docutils literal">await</tt> (and maybe not even then).  <a class="reference external" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task"><tt class="docutils literal">asyncio.create_task()</tt></a>
returns an <a class="reference external" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task"><tt class="docutils literal">asyncio.Task</tt></a> object that can be used to query the state of the
coroutine or cancel it; awaiting on the task object will cause the current
coroutine to be suspended until the task is complete, at which point the return
value of the task’s underlying coroutine is returned.</p>
<p>If you create multiple tasks and then <tt class="docutils literal">await</tt> on them one by one, a given
<tt class="docutils literal">await</tt> will not return a result until the task in question is done; if task
B finishes running while you’re still awaiting on task A, the coroutine doing
the awaiting will continue to be suspended until A is done, and when it then
later awaits on B, it will get back B’s return value immediately, because B is
already done.  For example, the following code:</p>
<pre class="code python literal-block">
<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">strftime</span>

<span class="k">def</span> <span class="nf">hms</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%H:%M:%S&quot;</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">operate</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">hms</span><span class="p">()</span><span class="si">}</span><span class="s2">: Spending </span><span class="si">{</span><span class="n">time</span><span class="si">}</span><span class="s2"> seconds doing operations ...&quot;</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">hms</span><span class="p">()</span><span class="si">}</span><span class="s2">: Operations done after </span><span class="si">{</span><span class="n">time</span><span class="si">}</span><span class="s2"> seconds!&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">amain</span><span class="p">():</span>
    <span class="n">task1</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">operate</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">42</span><span class="p">))</span>
    <span class="n">task2</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">operate</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">23</span><span class="p">))</span>
    <span class="n">r1</span> <span class="o">=</span> <span class="k">await</span> <span class="n">task1</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">hms</span><span class="p">()</span><span class="si">}</span><span class="s2">: task1 returned </span><span class="si">{</span><span class="n">r1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="k">await</span> <span class="n">task2</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">hms</span><span class="p">()</span><span class="si">}</span><span class="s2">: task2 returned </span><span class="si">{</span><span class="n">r2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">amain</span><span class="p">())</span>
</pre>
<p>outputs something like the following:</p>
<pre class="literal-block">
17:12:56: Spending 5 seconds doing operations ...
17:12:56: Spending 2 seconds doing operations ...
17:12:58: Operations done after 2 seconds!
17:13:01: Operations done after 5 seconds!
17:13:01: task1 returned 42
17:13:01: task2 returned 23
</pre>
<p>If you need to await on multiple coroutines but don’t care about the exact
order in which they finish, you can use <a class="reference external" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.gather"><tt class="docutils literal">asyncio.gather()</tt></a>,
<a class="reference external" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.as_completed"><tt class="docutils literal">asyncio.as_completed()</tt></a>, or <a class="reference external" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.wait"><tt class="docutils literal">asyncio.wait()</tt></a> to await on them together; <a class="reference external" href="https://hynek.me/articles/waiting-in-asyncio/">this
article</a> gives a good overview and explanation of the differences
between the functions.</p>
<p id="bgerr">You don’t have to await on a task if you don’t need its return value or don’t
need to be assured that it ever finishes, but if such a “background task”
raises an uncaught exception, <tt class="docutils literal">asyncio</tt> will complain.  One way to address
this is to attach a synchronous callback function to the task with
<tt class="docutils literal">Task.add_done_callback()</tt> that retrieves any uncaught exceptions with
<tt class="docutils literal">Task.exception()</tt>, like so:</p>
<pre class="code python literal-block">
<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">strftime</span>

<span class="k">def</span> <span class="nf">hms</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%H:%M:%S&quot;</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">bg_task</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">hms</span><span class="p">()</span><span class="si">}</span><span class="s2">: In the background&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Ouch&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">done_callback</span><span class="p">(</span><span class="n">task</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">task</span><span class="o">.</span><span class="n">exception</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">hms</span><span class="p">()</span><span class="si">}</span><span class="s2">: Task &lt;</span><span class="si">{</span><span class="n">task</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span><span class="si">}</span><span class="s2">&gt; raised an error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">hms</span><span class="p">()</span><span class="si">}</span><span class="s2">: Task &lt;</span><span class="si">{</span><span class="n">task</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span><span class="si">}</span><span class="s2">&gt; finished successfully&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">hms</span><span class="p">()</span><span class="si">}</span><span class="s2">: Task &lt;</span><span class="si">{</span><span class="n">task</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span><span class="si">}</span><span class="s2">&gt; was cancelled!&quot;</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">fg_task</span><span class="p">():</span>
    <span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">bg_task</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;bg_task&quot;</span><span class="p">)</span>
    <span class="n">task</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="n">done_callback</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">hms</span><span class="p">()</span><span class="si">}</span><span class="s2">: Now we sleep and let bg_task do its thing&quot;</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">hms</span><span class="p">()</span><span class="si">}</span><span class="s2">: I'm awake!&quot;</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">fg_task</span><span class="p">())</span>
</pre>
<p>The output from the above will look like:</p>
<pre class="literal-block">
17:16:33: Now we sleep and let bg_task do its thing
17:16:33: In the background
17:16:33: Task &lt;bg_task&gt; raised an error: Ouch
17:16:35: I'm awake!
</pre>
</div>
<div class="section" id="exception-handling">
<h2><a class="toc-backref" href="#contents">Exception Handling</a></h2>
<p>Whenever an exception occurs inside a coroutine, it propagates upwards to
whatever’s awaiting on it; if unhandled, it will propagate all the way out
through the <a class="reference external" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.run"><tt class="docutils literal">asyncio.run()</tt></a> call, at which point all still-running tasks are
cancelled.  If there is no chain of <tt class="docutils literal">await</tt>s leading to the “top-level”
coroutine (say, because you did <tt class="docutils literal">asyncio.create_task()</tt> and then didn’t await
on the result, letting it run in the background), <tt class="docutils literal">asyncio</tt> will end up
complaining when the coroutine is eventually garbage-collected.  See <a class="reference internal" href="#bgerr">the
passage above</a> on using <tt class="docutils literal">Task.add_done_callback()</tt> to handle such
errors.</p>
<p>For the specific case of <tt class="docutils literal">KeyboardInterrupt</tt>, the exception is raised in
whatever coroutine the main thread is currently running at the time.</p>
</div>
<div class="section" id="example-code">
<h2><a class="toc-backref" href="#contents">Example Code</a></h2>
<p><a class="reference external" href="https://gist.github.com/jwodder/c0ad1a5a0b6fda18c15dbdb405e1e549">This gist</a> provides an example of using asynchronous programming in Python
to download assets for one or more releases of a GitHub repository in parallel.
Try it out with an invocation like:</p>
<pre class="literal-block">
python download-assets.py --download-dir jq stedolan/jq jq-1.5 jq-1.6
</pre>
<p>The script requires Python 3.8 or higher and the <a class="reference external" href="https://github.com/jwodder/ghrepo">ghrepo</a> and <a class="reference external" href="https://www.python-httpx.org">httpx</a> packages on
PyPI to run.</p>
</div>
<div class="section" id="asynchronous-programming-vs-threads">
<h2><a class="toc-backref" href="#contents">Asynchronous Programming vs. Threads</a></h2>
<p>Asynchronous programming does not use threads; by default, all coroutines and
their operations are run in whichever thread called <a class="reference external" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.run"><tt class="docutils literal">asyncio.run()</tt></a>.  The
exception is when <a class="reference external" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.to_thread"><tt class="docutils literal">asyncio.to_thread()</tt></a> or <a class="reference external" href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.run_in_executor"><tt class="docutils literal">loop.run_in_executor()</tt></a> is used to
run a synchronous function in a separate thread (or, with the latter function,
even a separate process), returning an object that can be awaited on to receive
the function’s result.</p>
<p>If multiple threads call <a class="reference external" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.run"><tt class="docutils literal">asyncio.run()</tt></a> separately, each thread will get its
own event loop and collection of coroutines.</p>
<p>Note that each thread in a Python process has at most one event loop at a time,
and an event loop can only belong to one thread.  An important consequence of
this is that, if you have a synchronous function <tt class="docutils literal">foo()</tt> that calls
<a class="reference external" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.run"><tt class="docutils literal">asyncio.run()</tt></a> on some coroutine, then <tt class="docutils literal">foo()</tt> cannot be called by another
coroutine, because that would lead to two event loops in the same thread, which
doesn’t work.</p>
<p>Compared to threads, asynchronous programming provides the following
advantages:</p>
<ul>
<li><p class="first">In asynchronous programming, the coroutine being executed can only change
when the current coroutine uses <tt class="docutils literal">await</tt> or similar.  This allows the
programmer to be assured that, between <tt class="docutils literal">await</tt>s in the same coroutine,
operations will not be interfered with and data will not be modified by other
coroutines.</p>
<p>When using threads, on the other hand, the running thread <a class="footnote-reference" href="#gil" id="footnote-reference-1">[1]</a> can change
at almost any point as chosen by the interpreter, which necessitates careful
programming and copious use of locks in order to ensure that variables are
not modified by one thread “behind the back of” another thread that’s also
using them.</p>
</li>
<li><p class="first">If you’ve done serious work with threads, you’ve likely encountered the fact
that you cannot “kill” a thread in the middle of its execution unless the
“killable” thread is deliberately programmed to allow for this by, say,
regularly checking some flag and exiting if it’s true.  Asynchronous
programming, on the other hand, makes it possible to <em>cancel</em> a running
coroutine via the <tt class="docutils literal">asyncio.Task.cancel()</tt> method; once a coroutine is
cancelled, the next time the event loop checks on it while it’s suspended on
an <tt class="docutils literal">await</tt> or similar, the coroutine will be resumed, but instead of
receiving the value it was awaiting for, an <tt class="docutils literal">asyncio.CancelledError</tt> will
be raised at the <tt class="docutils literal">await</tt> expression, likely putting an end to the
coroutine’s execution.</p>
</li>
</ul>
<table class="docutils footnote" frame="void" id="gil" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>Recall that, due to Python’s global interpreter lock (GIL),
regardless of how many threads a Python program uses or how many cores your
machine has, only one thread will be executing Python bytecode at any
moment.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="async-version-history">
<h2><a class="toc-backref" href="#contents">Async Version History</a></h2>
<p>Here follows a list of the notable developments &amp; changes in asynchronous
programming across Python versions.</p>
<p class="rubric">Python 3.4</p>
<p>The <tt class="docutils literal">asyncio</tt> module is added, implementing <a class="reference external" href="https://peps.python.org/pep-3156">PEP 3156</a>.  This enables the
creation of coroutines via the <tt class="docutils literal">&#64;asyncio.coroutine</tt> decorator; within a
coroutine, awaiting is performed with <tt class="docutils literal">yield from</tt>.  (Support for creating
coroutines in this way would later be deprecated in Python 3.8 and removed in
Python 3.11.)</p>
<p>Most of the functionality added in this version is now categorized as the “low
level” part of <tt class="docutils literal">asyncio</tt>.</p>
<p class="rubric">Python 3.5</p>
<p><a class="reference external" href="https://peps.python.org/pep-0492">PEP 492</a> implemented:</p>
<ul>
<li><p class="first">It is now possible to define coroutines via <tt class="docutils literal">async def</tt> and await with
<tt class="docutils literal">await</tt>.</p>
<ul>
<li><p class="first">In Python 3.5, <tt class="docutils literal">yield</tt> cannot be used inside the body of an <tt class="docutils literal">async def</tt>
coroutine function.</p>
</li>
</ul>
</li>
<li><p class="first">Asynchronous iteration with <tt class="docutils literal">async for</tt> is now possible.</p>
</li>
<li><p class="first">Asynchronous context managers are now supported via <tt class="docutils literal">async with</tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal">__await__()</tt>, <tt class="docutils literal">__aiter__()</tt>, <tt class="docutils literal">__anext__()</tt>, <tt class="docutils literal">__aenter__()</tt>, and
<tt class="docutils literal">__aexit__()</tt> special methods added</p>
</li>
<li><p class="first">Originally, <tt class="docutils literal">__aiter__()</tt> methods were expected to be coroutines (or
anything else returning an awaitable) resolving to asynchronous iterators.
This was changed in 3.5.2 to have <tt class="docutils literal">__aiter__()</tt> instead return an
asynchronous iterator directly.  Returning an awaitable from <tt class="docutils literal">__aiter__()</tt>
produces a <tt class="docutils literal">PendingDeprecationWarning</tt> starting in 3.5.2, a
<tt class="docutils literal">DeprecationWarning</tt> starting in 3.6, and a <tt class="docutils literal">RuntimeError</tt> starting in
3.7.</p>
</li>
</ul>
<p class="rubric">Python 3.6</p>
<ul>
<li><p class="first"><tt class="docutils literal">yield</tt> can now be used in the body of an <tt class="docutils literal">async def</tt> coroutine function,
thereby enabling asynchronous generators (<a class="reference external" href="https://peps.python.org/pep-0525">PEP 525</a>).  (<tt class="docutils literal">yield from</tt>
remains prohibited, though.)</p>
</li>
<li><p class="first"><tt class="docutils literal">async for</tt> can now be used in list, set, &amp; dict comprehensions and in
generator expressions</p>
</li>
<li><p class="first"><tt class="docutils literal">await</tt> expressions can now be used in any comprehension</p>
</li>
<li><p class="first">Using <tt class="docutils literal">async</tt> or <tt class="docutils literal">await</tt> as an identifier now generates a
<tt class="docutils literal">DeprecationWarning</tt></p>
</li>
</ul>
<p class="rubric">Python 3.7</p>
<ul>
<li><p class="first"><tt class="docutils literal">async</tt> and <tt class="docutils literal">await</tt> are now reserved keywords</p>
</li>
<li><p class="first"><tt class="docutils literal">asyncio.run()</tt> added</p>
</li>
<li><p class="first"><tt class="docutils literal">asyncio.create_task()</tt> added</p>
</li>
</ul>
<p class="rubric">Python 3.8</p>
<ul>
<li><p class="first">Running <tt class="docutils literal">python <span class="pre">-m</span> asyncio</tt> now starts an async REPL</p>
</li>
<li><p class="first"><tt class="docutils literal">&#64;asyncio.coroutine()</tt> is now deprecated</p>
</li>
<li><p class="first">Passing a <tt class="docutils literal">loop</tt> parameter is now deprecated for most of <tt class="docutils literal">asyncio</tt>’s
high-level API</p>
</li>
<li><p class="first"><tt class="docutils literal">asyncio.CancelledError</tt> now inherits directly from <tt class="docutils literal">BaseException</tt>
instead of <tt class="docutils literal">Exception</tt></p>
</li>
</ul>
<p class="rubric">Python 3.9</p>
<ul>
<li><p class="first"><tt class="docutils literal">asyncio.to_thread()</tt> added</p>
</li>
</ul>
<p class="rubric">Python 3.10</p>
<ul>
<li><p class="first"><tt class="docutils literal">aiter()</tt> and <tt class="docutils literal">anext()</tt> functions added</p>
</li>
<li><p class="first">The <tt class="docutils literal">loop</tt> parameter (deprecated in Python 3.8) is now removed from most of
<tt class="docutils literal">asyncio</tt>’s high-level API</p>
</li>
</ul>
<p class="rubric">Python 3.11</p>
<ul>
<li><p class="first"><tt class="docutils literal">asyncio.TaskGroup</tt> added</p>
</li>
<li><p class="first"><tt class="docutils literal">&#64;asyncio.coroutine</tt> (deprecated in Python 3.8) is now removed</p>
</li>
</ul>
</div>
<div class="section" id="alternative-async-implementations">
<h2><a class="toc-backref" href="#contents">Alternative Async Implementations</a></h2>
<p>While all the code we’ve shown so far uses the Python standard library’s
<tt class="docutils literal">asyncio</tt> module, it’s not required to use this to work with coroutines.
Alternative async library implementations exist that define their own event
loops and primitive operations.  The more notable implementations include:</p>
<ul>
<li><p class="first"><a class="reference external" href="https://github.com/python-trio/trio">trio</a> seeks to enable <em>structured
concurrency</em> [<a class="reference external" href="https://en.wikipedia.org/wiki/Structured_concurrency">wiki</a>] in asynchronous code.  In trio, a collection of tasks
are run concurrently by grouping them together under a <em>nursery</em> (also known
as a <em>task group</em>); if one of the tasks in a nursery raises an error, all
the other tasks in the same nursery are automatically cancelled.</p>
</li>
<li><p class="first"><a class="reference external" href="https://github.com/dabeaz/curio">curio</a> is an <tt class="docutils literal">asyncio</tt> alternative
featuring a more streamlined API and intended to be easier to reason about</p>
</li>
</ul>
<p>In general, different async implementations are incompatible, and features from
different implementations cannot be used in the same code unless you make
careful use of whatever compatibility facilities they may provide.</p>
<p>In fact, just being able to use the same code unmodified regardless of whether
using implementation A or implementation B is tricky, as all implementations
use different primitives.  Libraries to help you with that include:</p>
<ul>
<li><p class="first"><a class="reference external" href="https://github.com/python-trio/sniffio">sniffio</a> can be used to detect
which async library is in use</p>
</li>
<li><p class="first"><a class="reference external" href="https://github.com/agronholm/anyio">anyio</a> provides a common API (based on
trio) that can be used to run the same code under both asyncio and trio (and
previously curio, until it &amp; anyio <a class="reference external" href="https://github.com/agronholm/anyio/issues/185">parted ways</a> in anyio 3.0)</p>
</li>
</ul>
</div>
</div>
    </article>
</section>
        </div>
    </div>

        <footer id="kbits-theme-footer">
<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
    <img alt="Creative Commons License" style="border-width: 0; vertical-align: middle;" src="https://i.creativecommons.org/l/by/4.0/80x15.png" />
</a>

Copyright © 2020–2022 <a xmlns:cc="http://creativecommons.org/ns#"
href="https://github.com/jwodder" property="cc:attributionName"
rel="cc:attributionURL">John T. Wodder II</a>.  This site's content is licensed under a
<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative
Commons Attribution 4.0 International License</a>.
</footer>
</body>
</html>